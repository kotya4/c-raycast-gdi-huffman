#include <stdio.h> // fopen
#include <stdint.h> // uint8_t
#include <math.h> // log2, lround, ceil
#include <time.h> // time
#include "vectorbit.h"
#include "minmax.h"
#include "bmp.h"


#include "imgs.h"
#define OUTPUT "imge.h"


int
main () {
  int status = 0;

  vectorbit_t colors     = { NULL, 0, 0, 0 }; // 8 bits per image ( rgb332 )
  vectorbit_t colorsnum  = { NULL, 0, 0, 0 }; // 4 bits per image ( 16 colors max )
  vectorbit_t imagesizes = { NULL, 0, 0, 0 }; // 4 bits per image ( WxH : 32, 64, 128, 256 )
  vectorbit_t images     = { NULL, 0, 0, 0 }; // various bits per image

  for ( size_t i = 0; i < IMGS_LENGTH; ++i ) {

    const char *path = imgs[ i ];

    // make bmp and bmpi
    bmp_t bmp;
    bmpi_t bmpi;
    status = bmp_from_file ( &bmp, path );
    if ( status < 0 ) {
      printf ( "bmp_from_file returns status %d on file %s\n", status, path );
      continue;
    }
    status = bmp_mirror ( &bmp );
    if ( status < 0 ) {
      printf ( "bmp_mirror returns status %d on file %s\n", status, path );
      continue;
    }
    status = bmp_to_bmpi ( &bmp, &bmpi, 0 );
    if ( status < 0 ) {
      printf ( "bmp_to_bmpi returns status %d on file %s\n", status, path );
      continue;
    }
    bmp_kill ( &bmp );

    // parse size
    uint8_t w, h;
    if      ( bmpi.w ==  32 ) w = 0b00;
    else if ( bmpi.w ==  64 ) w = 0b01;
    else if ( bmpi.w == 128 ) w = 0b10;
    else if ( bmpi.w == 256 ) w = 0b11;
    else {
      printf ( "file %s has incompatible width %d\n", path, bmpi.w );
      continue;
    }
    if      ( bmpi.h ==  32 ) h = 0b00;
    else if ( bmpi.h ==  64 ) h = 0b01;
    else if ( bmpi.h == 128 ) h = 0b10;
    else if ( bmpi.h == 256 ) h = 0b11;
    else {
      printf ( "file %s has incompatible height %d\n", path, bmpi.h );
      continue;
    }

    // push size
    status = vectorbit_push_many ( &imagesizes, w, 2 );
    if ( status < 0 ) {
      printf ( "vectorbit_push_many returns status" );
      printf ( " %d on file %s w %d\n", status, path, w );
      continue;
    }
    status = vectorbit_push_many ( &imagesizes, h, 2 );
    if ( status < 0 ) {
      printf ( "vectorbit_push_many returns status" );
      printf ( " %d on file %s h %d\n", status, path, h );
      continue;
    }

    // push palette length
    if ( bmpi.p.length > 16 || bmpi.p.length < 1 ) {
      printf ( "incompatible palette size %d", bmpi.p.length );
      printf ( " on file %s\n", path );
      continue;
    }
    status = vectorbit_push_many ( &colorsnum, bmpi.p.length - 1, 4 );
    if ( status < 0 ) {
      printf ( "vectorbit_push_many returns status" );
      printf ( " %d on file %s palette length %d\n", status, path, bmpi.p.length );
      continue;
    }

    // push palette
    for ( size_t k = 0; k < bmpi.p.length; ++k ) {
      #define CVT8TO3( v ) ( lround ( max ( 0, v - 16 ) / 32.0 ) & 0b111 )
      #define CVT8TO2( v ) ( lround ( max ( 0, v - 32 ) / 64.0 ) & 0b11  )
      const uint8_t rgb332
        = CVT8TO3 ( bmpi.p.rgb24[ k ].r ) << 5
        | CVT8TO3 ( bmpi.p.rgb24[ k ].g ) << 2
        | CVT8TO2 ( bmpi.p.rgb24[ k ].b ) << 0 ;
      status = vectorbit_push_many ( &colors, rgb332, 8 );
      if ( status < 0 ) {
        printf ( "vectorbit_push_many returns status" );
        printf ( " %d on file %s palette index %d\n", status, path, k );
        continue;
      }
    }

    // push index array
    const size_t indexcap = ( size_t ) ceil ( log2 ( bmpi.p.length ) );
    for ( size_t k = 0; k < bmpi.l; ++k ) {
      status = vectorbit_push_many ( &images, bmpi.a[ k ], indexcap );
      if ( status < 0 ) {
        printf ( "vectorbit_push_many returns status" );
        printf ( " %d on file %s array index %d\n", status, path, k );
        continue;
      }
    }

    bmpi_kill ( &bmpi );

  }

  // write file

  FILE *f = fopen ( OUTPUT, "w" );
  if ( !f ) {
    printf ( "fopen: cannot write file %s\n", OUTPUT );
  } else {
    fprintf ( f, "// This file was generated by imgc at POSIX TIME %d\n", time ( NULL ) );
    fprintf ( f, "#ifndef IMGE_H\n" );
    fprintf ( f, "#define IMGE_H\n" );
    fprintf ( f, "\n" );
    fprintf ( f, "#define IMGE_COLORS_LENGTH %d\n", colors.byteindex + 1 );
    fprintf ( f, "#define IMGE_COLORSNUM_LENGTH %d\n", colorsnum.byteindex + 1 );
    fprintf ( f, "#define IMGE_IMAGESIZES_LENGTH %d\n", imagesizes.byteindex + 1 );
    fprintf ( f, "#define IMGE_IMAGES_LENGTH %d\n", images.byteindex + 1 );
    fprintf ( f, "#define IMGE_FILES_LENGTH %d\n", IMGS_LENGTH );
    fprintf ( f, "\n" );
    fprintf ( f, "unsigned char imge_colors[ IMGE_COLORS_LENGTH ] = {" );
    for ( size_t i = 0; i < colors.byteindex + 1; ++i )
      fprintf ( f, "%d,", colors.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "unsigned char imge_colorsnum[ IMGE_COLORSNUM_LENGTH ] = {" );
    for ( size_t i = 0; i < colorsnum.byteindex + 1; ++i )
      fprintf ( f, "%d,", colorsnum.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "unsigned char imge_imagesizes[ IMGE_IMAGESIZES_LENGTH ] = {" );
    for ( size_t i = 0; i < imagesizes.byteindex + 1; ++i )
      fprintf ( f, "%d,", imagesizes.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "unsigned char imge_images[ IMGE_IMAGES_LENGTH ] = {" );
    for ( size_t i = 0; i < images.byteindex + 1; ++i )
      fprintf ( f, "%d,", images.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "\n" );
    // because of various image size we must store images bitslength
    fprintf ( f, "#define IMGE_IMAGES_BITSLENGTH %d\n", images.bitslength );
    fprintf ( f, "\n" );
    fprintf ( f, "#endif // IMGE_H\n" );
    fclose ( f );
    printf ( "created %s\n", OUTPUT );
  }

  free ( colors.array );
  free ( colorsnum.array );
  free ( imagesizes.array );
  free ( images.array );

}
